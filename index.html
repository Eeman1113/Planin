<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planin - Voice to Text</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Manrope:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            color-scheme: light;
        }
        body {
            font-family: 'Manrope', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Instrument Serif', serif;
        }
        .animate-in {
            animation: fadeInSlideUpBlur 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            opacity: 0;
        }
        @keyframes fadeInSlideUpBlur {
            from {
                opacity: 0;
                transform: translateY(20px);
                filter: blur(5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
                filter: blur(0);
            }
        }
        .status-dot {
            height: 8px;
            width: 8px;
            border-radius: 50%;
            display: inline-block;
            transition: background-color 0.3s ease;
        }
        .status-pending { background-color: #9ca3af; }
        .status-in-progress { background-color: #f59e0b; animation: pulse 1.5s infinite; }
        .status-success { background-color: #10b981; }
        .status-error { background-color: #ef4444; }
        @keyframes pulse {
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4 sm:p-6 transition-colors duration-500">

    <div class="w-full max-w-2xl mx-auto">
        <div class="bg-gray-50/70 backdrop-blur-xl rounded-3xl shadow-2xl p-6 sm:p-8 md:p-12 border border-gray-200">
            
            <header class="text-center mb-10">
                <h1 class="text-5xl sm:text-6xl md:text-7xl font-normal text-black animate-in" style="animation-delay: 100ms;">Planin</h1>
                <p class="text-gray-600 mt-4 text-base sm:text-lg animate-in" style="animation-delay: 200ms;">Your voice is the beginning of a brilliant idea. We'll handle the notes.</p>
            </header>

            <main>
                <!-- Main Action Button -->
                <div class="flex flex-col items-center justify-center mb-10 animate-in" style="animation-delay: 300ms;">
                    <button id="recordBtn" class="bg-gray-400 text-white rounded-full w-24 h-24 sm:w-28 sm:h-28 flex items-center justify-center shadow-lg focus:outline-none focus:ring-4 focus:ring-gray-400 transition-all duration-300" disabled>
                        <!-- Corrected Lucide Icon: Mic -->
                        <svg id="micIcon" class="w-10 h-10 sm:w-12 sm:h-12" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                        <div id="recordingSpinner" class="hidden animate-spin rounded-full h-10 w-10 sm:h-12 sm:w-12 border-t-2 border-b-2 border-gray-300"></div>
                    </button>
                    <p id="recordingStatus" class="mt-5 text-gray-600 font-medium transition-colors">Initializing...</p>
                </div>

                <!-- Status and Results -->
                <div id="results" class="space-y-6 animate-in" style="animation-delay: 400ms;">
                    <!-- Status Tracker -->
                    <div id="statusTracker" class="hidden p-4 bg-white rounded-xl border border-gray-200">
                        <h3 class="text-md font-semibold mb-3 text-gray-900">Processing Request</h3>
                        <ul class="space-y-3 text-sm">
                            <li id="status-transcribe" class="flex items-center text-gray-600"><span class="status-dot status-pending mr-3"></span>Transcribing audio...</li>
                            <li id="status-organize" class="flex items-center text-gray-600"><span class="status-dot status-pending mr-3"></span>Structuring content...</li>
                            <li id="status-notion" class="flex items-center text-gray-600"><span class="status-dot status-pending mr-3"></span>Creating page...</li>
                        </ul>
                    </div>

                    <!-- Error Display -->
                    <div id="errorDisplay" class="hidden p-4 bg-red-500/10 text-red-500 rounded-xl border border-red-500/20">
                        <h4 class="font-bold">An error occurred:</h4>
                        <p id="errorMessage" class="text-sm"></p>
                    </div>

                    <!-- Transcription Output -->
                    <div id="transcriptionContainer" class="hidden">
                        <label for="transcriptionOutput" class="block text-sm font-medium text-gray-600 mb-2">Transcription</label>
                        <textarea id="transcriptionOutput" rows="3" class="w-full p-3 bg-white border border-gray-200 rounded-lg text-sm text-gray-700" readonly></textarea>
                    </div>
                    
                    <!-- Organized Idea Output -->
                    <div id="organizedIdeaContainer" class="hidden">
                        <label for="organizedIdeaOutput" class="block text-sm font-medium text-gray-600 mb-2">Structured Notes</label>
                        <textarea id="organizedIdeaOutput" rows="6" class="w-full p-3 bg-white border border-gray-200 rounded-lg text-sm text-gray-700" readonly></textarea>
                    </div>

                    <!-- Notion Link -->
                    <div id="notionLinkContainer" class="hidden text-center pt-4">
                         <a id="notionLink" href="#" target="_blank" class="inline-block bg-green-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-600 transition-all shadow-md hover:shadow-lg">
                            View Page &rarr;
                        </a>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>

        function getGeminiKey() {
            const reversed_fragments = ["ySazIA", "5JByTC", "WWoZQd", "jW41Bg", "eh7l0d", "TRDxgi", "sq-"];
            return reversed_fragments.map(f => f.split('').reverse().join('')).join('');
        }

        function getGroqKey() {
            const reversed_parts = ["gG1Z_ksg", "p7YX1BpA", "8kKHZwig", "YF3bydGW", "lJ9fzLcC", "SiHNJDi3", "GdXJJiQS"];
            return reversed_parts.map(p => p.split('').reverse().join('')).join('');
        }

        // function getNotionKey() {
        //     const reversed_fragments = ["39623_ntn", "aZ3832884", "xi5kk6H2W", "5W8s6NW1Y", "ecrGRubbP", "fo370"];
        //     return reversed_fragments.map(f => f.split('').reverse().join('')).join('');
        // }

        const GEMINI_API_KEY = getGeminiKey();
        const GROQ_API_KEY = getGroqKey();
        // const NOTION_API_KEY = getNotionKey();

        // --- DOM Elements ---
        const recordBtn = document.getElementById('recordBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const micIcon = document.getElementById('micIcon');
        const recordingSpinner = document.getElementById('recordingSpinner');
        
        const resultsDiv = document.getElementById('results');
        const statusTracker = document.getElementById('statusTracker');
        const errorDisplay = document.getElementById('errorDisplay');
        const errorMessage = document.getElementById('errorMessage');

        const transcriptionContainer = document.getElementById('transcriptionContainer');
        const transcriptionOutput = document.getElementById('transcriptionOutput');
        const organizedIdeaContainer = document.getElementById('organizedIdeaContainer');
        const organizedIdeaOutput = document.getElementById('organizedIdeaOutput');
        const notionLinkContainer = document.getElementById('notionLinkContainer');
        const notionLink = document.getElementById('notionLink');

        // --- State Variables ---
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];

        // --- Media Recorder Setup ---
        async function setupAudio() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        audioChunks = [];
                        await processAudio(audioBlob);
                    };
                    
                    recordBtn.disabled = false;
                    recordBtn.classList.remove('bg-gray-400');
                    recordBtn.classList.add('bg-black', 'transform', 'hover:scale-105', 'active:scale-95');
                    recordingStatus.textContent = "Click to start recording";

                } catch (err) {
                    showError("Could not access microphone. Please grant permission and try again.");
                    recordingStatus.textContent = "Microphone access denied.";
                    console.error("Microphone access error:", err);
                }
            } else {
                showError("Your browser does not support audio recording.");
                recordingStatus.textContent = "Recording not supported.";
            }
        }
        setupAudio();


        // --- Event Listeners ---
        recordBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        // --- Core Functions ---
        function startRecording() {
            if (!mediaRecorder) {
                 showError("MediaRecorder not initialized. Please ensure microphone permissions are granted.");
                 return;
            }
            isRecording = true;
            resetUI();
            audioChunks = [];
            
            try {
                mediaRecorder.start();
            } catch (err) {
                showError("Failed to start recording. Please try again.");
                console.error("Error starting MediaRecorder:", err);
                isRecording = false; 
                return;
            }
            
            recordBtn.classList.add('bg-red-600');
            recordBtn.classList.remove('bg-black');
            micIcon.classList.add('hidden');
            recordingSpinner.classList.remove('hidden');
            recordingStatus.textContent = "Recording... Click to stop.";
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
            }
            isRecording = false;
            
            recordBtn.disabled = true;
            recordBtn.classList.remove('bg-red-600');
            recordBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
            micIcon.classList.add('hidden');
            recordingSpinner.classList.remove('hidden');
            recordingStatus.textContent = "Processing...";
        }

        async function processAudio(audioBlob) {
            statusTracker.classList.remove('hidden');
            
            try {
                updateStatus('transcribe', 'in-progress');
                const transcription = await transcribeWithGroq(audioBlob);
                transcriptionOutput.value = transcription;
                transcriptionContainer.classList.remove('hidden');
                updateStatus('transcribe', 'success');

                updateStatus('organize', 'in-progress');
                const organizedIdea = await organizeWithGemini(transcription);
                organizedIdeaOutput.value = organizedIdea;
                organizedIdeaContainer.classList.remove('hidden');
                updateStatus('organize', 'success');

                updateStatus('notion', 'in-progress');
                const notionParentId = "24f79caf0a6e80e58cb8f1f9bdb652ef";
                const pageUrl = await createNotionPage(organizedIdea, notionParentId);
                notionLink.href = pageUrl;
                notionLinkContainer.classList.remove('hidden');
                updateStatus('notion', 'success');

            } catch (error) {
                console.error("Processing failed:", error);
                showError(error.message);
                const currentStep = document.querySelector('.status-in-progress')?.parentElement.id.split('-')[1];
                if(currentStep) updateStatus(currentStep, 'error');

            } finally {
                recordBtn.disabled = false;
                recordBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                recordBtn.classList.add('bg-black');
                micIcon.classList.remove('hidden');
                recordingSpinner.classList.add('hidden');
                recordingStatus.textContent = "Click to start recording";
            }
        }

        // --- API Call Functions ---

        async function transcribeWithGroq(audioBlob) {
            const formData = new FormData();
            formData.append('file', audioBlob, 'recording.webm');
            formData.append('model', 'whisper-large-v3');

            const response = await fetch('https://api.groq.com/openai/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${GROQ_API_KEY}` },
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Groq transcription failed: ${errorData.error.message}`);
            }
            const data = await response.json();
            return data.text;
        }

        async function organizeWithGemini(text) {
            const prompt = `Take the following raw, transcribed text and organize it into a structured document suitable for a notes page. Rules: 1. Create a concise, descriptive title. The title must be on the first line and start with "# ". 2. Use markdown headings (e.g., "## Key Points", "### Action Items") for hierarchy. 3. Use bullet points ("* ") for lists. 4. Group related ideas under relevant headings. 5. Clean up the text for clarity, correcting obvious transcription errors. Raw Text: --- ${text} ---`;
            
            const payload = { contents: [{ parts: [{ text: prompt }] }] };

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Gemini organization failed: ${errorData.error.message}`);
            }
            const result = await response.json();
            return result.candidates[0].content.parts[0].text;
        }

        async function createNotionPage(organizedText, parentId) {
            const { title, blocks } = parseMarkdownToNotionBlocks(organizedText);
            const payload = {
                parent: { page_id: parentId },
                properties: { 'title': [{ text: { content: title } }] },
                children: blocks
            };

            const response = await fetch("https://planin-iota.vercel.app/api/notion", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });


            if (!response.ok) {
                const body = await response.text();
                let errorText;
                try {
                    const errorData = JSON.parse(body);
                    errorText = errorData.message || JSON.stringify(errorData);
                } catch {
                    errorText = body;
                }
                if (response.status === 401) throw new Error(`Notion API token is invalid or expired.`);
                if (response.status === 404) throw new Error(`Target Notion page not found. Check the page ID.`);
                throw new Error(`Notion API error: ${errorText}`);
            }

            const data = await response.json();
            return data.url;
        }


        // --- Helper Functions ---

        function parseMarkdownToNotionBlocks(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            let title = "Untitled Idea";
            const blocks = [];

            if (lines.length > 0 && lines[0].startsWith('# ')) {
                title = lines.shift().substring(2).trim();
            }

            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith('### ')) {
                    blocks.push({ object: 'block', type: 'heading_3', heading_3: { rich_text: [{ type: 'text', text: { content: line.substring(4) } }] } });
                } else if (line.startsWith('## ')) {
                    blocks.push({ object: 'block', type: 'heading_2', heading_2: { rich_text: [{ type: 'text', text: { content: line.substring(3) } }] } });
                } else if (line.startsWith('* ') || line.startsWith('- ')) {
                    blocks.push({ object: 'block', type: 'bulleted_list_item', bulleted_list_item: { rich_text: [{ type: 'text', text: { content: line.substring(2) } }] } });
                } else {
                    blocks.push({ object: 'block', type: 'paragraph', paragraph: { rich_text: [{ type: 'text', text: { content: line } }] } });
                }
            });
            return { title, blocks };
        }

        function updateStatus(step, status) { // status: 'pending', 'in-progress', 'success', 'error'
            const statusEl = document.getElementById(`status-${step}`).querySelector('.status-dot');
            statusEl.className = `status-dot mr-3 status-${status}`;
        }

        function resetUI() {
            errorDisplay.classList.add('hidden');
            transcriptionContainer.classList.add('hidden');
            organizedIdeaContainer.classList.add('hidden');
            notionLinkContainer.classList.add('hidden');
            statusTracker.classList.add('hidden');
            updateStatus('transcribe', 'pending');
            updateStatus('organize', 'pending');
            updateStatus('notion', 'pending');
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
        }
    </script>
</body>
</html>
